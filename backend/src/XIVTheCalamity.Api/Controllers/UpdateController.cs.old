using Microsoft.AspNetCore.Mvc;
using XIVTheCalamity.Api.Extensions;
using XIVTheCalamity.Api.Models;
using XIVTheCalamity.Game.Models;
using XIVTheCalamity.Game.Services;

namespace XIVTheCalamity.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class UpdateController : ControllerBase
{
    private readonly ILogger<UpdateController> _logger;
    private readonly UpdateManager _updateManager;
    private readonly GameVersionService _versionService;

    public UpdateController(
        ILogger<UpdateController> logger,
        UpdateManager updateManager,
        GameVersionService versionService)
    {
        _logger = logger;
        _updateManager = updateManager;
        _versionService = versionService;
    }

    /// <summary>
    /// Check local game version
    /// </summary>
    [HttpGet("version")]
    public IActionResult GetLocalVersion([FromQuery] string gamePath)
    {
        try
        {
            if (string.IsNullOrEmpty(gamePath) || !Directory.Exists(gamePath))
            {
                return this.BadRequestError("VALIDATION_FAILED", "Invalid game path");
            }

            var versions = _versionService.GetLocalVersions(gamePath);
            return this.SuccessResult(versions);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to read game version");
            return this.InternalError("Failed to read game version", ex.Message);
        }
    }

    /// <summary>
    /// Check for updates only (no installation)
    /// </summary>
    [HttpPost("check-only")]
    public async Task<IActionResult> CheckUpdates([FromBody] CheckUpdateRequest request, CancellationToken cancellationToken)
    {
        try
        {
            if (string.IsNullOrEmpty(request.GamePath) || !Directory.Exists(request.GamePath))
            {
                return this.BadRequestError("VALIDATION_FAILED", "Invalid game path");
            }

            var result = await _updateManager.CheckUpdatesAsync(request.GamePath, cancellationToken);
            return this.SuccessResult(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to check updates");
            return this.InternalError("Failed to check updates", ex.Message);
        }
    }

    /// <summary>
    /// Check and install updates with SSE progress streaming
    /// Uses IAsyncEnumerable for progress reporting
    /// </summary>
    [HttpGet("install")]
    public async Task InstallUpdates([FromQuery] string gamePath, CancellationToken cancellationToken)
    {
        Response.ContentType = "text/event-stream";
        Response.Headers.Append("Cache-Control", "no-cache");
        Response.Headers.Append("Connection", "keep-alive");

        if (string.IsNullOrEmpty(gamePath) || !Directory.Exists(gamePath))
        {
            await SendSseEvent("error", new { 
                message = "Invalid game path",
                code = "VALIDATION_FAILED"
            }, cancellationToken);
            return;
        }

        try
        {
            await foreach (var progress in _updateManager.CheckAndInstallUpdatesAsync(gamePath, cancellationToken))
            {
                var eventType = progress.HasError ? "error"
                    : progress.IsComplete ? "complete"
                    : "progress";

                await SendSseEvent(eventType, progress, cancellationToken);
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Update installation cancelled");
            await SendSseEvent("cancelled", new { message = "Update cancelled by user" }, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Update installation failed");
            await SendSseEvent("error", new { 
                message = ex.Message,
                code = "UPDATE_FAILED"
            }, cancellationToken);
        }
    }

    /// <summary>
    /// Send SSE event
    /// </summary>
    private async Task SendSseEvent(string eventType, object data, CancellationToken cancellationToken)
    {
        var options = new System.Text.Json.JsonSerializerOptions
        {
            PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };
        
        var json = System.Text.Json.JsonSerializer.Serialize(data, options);
        await Response.WriteAsync($"event: {eventType}\n", cancellationToken);
        await Response.WriteAsync($"data: {json}\n\n", cancellationToken);
        await Response.Body.FlushAsync(cancellationToken);
    }

    /// <summary>
    /// [Deprecated] Use GET /api/update/install instead
    /// </summary>
    [HttpPost("check")]
    public async Task<IActionResult> CheckAndInstallUpdates([FromBody] CheckUpdateRequest request)
    {
        _logger.LogWarning("POST /api/update/check is deprecated, use GET /api/update/install with SSE instead");
        
        try
        {
            if (string.IsNullOrEmpty(request.GamePath) || !Directory.Exists(request.GamePath))
            {
                return this.BadRequestError("VALIDATION_FAILED", "Invalid game path");
            }

            // Run update without progress reporting (legacy mode)
            var checkResult = await _updateManager.CheckUpdatesAsync(request.GamePath);
            
            if (!checkResult.NeedsUpdate)
            {
                return this.SuccessResult(checkResult);
            }

            // Cannot report progress in non-SSE endpoint, return error
            return this.BadRequestError("USE_SSE_ENDPOINT", 
                "Updates are available. Please use GET /api/update/install with SSE for progress reporting.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to check updates");
            return this.InternalError("Failed to check updates", ex.Message);
        }
    }

    /// <summary>
    /// [Deprecated] Cancel download - no longer applicable with new architecture
    /// </summary>
    [HttpPost("cancel")]
    public IActionResult CancelDownload()
    {
        _logger.LogWarning("POST /api/update/cancel is deprecated - use cancellation token in SSE endpoint");
        return this.SuccessResult(new { message = "Use cancellation token to cancel SSE stream" });
    }

    /// <summary>
    /// [Deprecated] Get current download progress - no longer applicable
    /// </summary>
    [HttpGet("progress")]
    public IActionResult GetProgress()
    {
        _logger.LogWarning("GET /api/update/progress is deprecated - use SSE endpoint instead");
        return this.SuccessResult(new { 
            isDownloading = false,
            message = "Use GET /api/update/install with SSE for real-time progress"
        });
    }

    /// <summary>
    /// [Deprecated] SSE progress push - replaced by install endpoint
    /// </summary>
    [HttpGet("progress-stream")]
    public async Task GetProgressStream(CancellationToken cancellationToken)
    {
        _logger.LogWarning("GET /api/update/progress-stream is deprecated, use GET /api/update/install instead");
        
        Response.ContentType = "text/event-stream";
        await SendSseEvent("error", new { 
            message = "This endpoint is deprecated. Use GET /api/update/install instead.",
            code = "ENDPOINT_DEPRECATED"
        }, cancellationToken);
    }

    // Keep old endpoints for backward compatibility (deprecated)
    
    /// <summary>
    /// [Deprecated] Background update: Please use POST /api/update/check
    /// </summary>
    [HttpPost("check-background")]
    public async Task<IActionResult> CheckUpdatePlanA([FromBody] CheckUpdateRequest request)
    {
        _logger.LogWarning("check-background is deprecated, use check instead");
        return await CheckAndInstallUpdates(request);
    }

    /// <summary>
    /// [Deprecated] Update after login: Please use POST /api/update/check (SessionId no longer required)
    /// </summary>
    [HttpPost("check-login")]
    public async Task<IActionResult> CheckUpdatePlanB([FromBody] CheckUpdatePlanBRequest request)
    {
        _logger.LogWarning("check-login is deprecated, use check instead (sessionId is no longer required)");
        return await CheckAndInstallUpdates(new CheckUpdateRequest { GamePath = request.GamePath });
    }
}

/// <summary>
/// Check update request
/// </summary>
public class CheckUpdateRequest
{
    public string GamePath { get; set; } = string.Empty;
}

/// <summary>
/// [Deprecated] Update after login check update request
/// </summary>
public class CheckUpdatePlanBRequest
{
    public string GamePath { get; set; } = string.Empty;
    public string SessionId { get; set; } = string.Empty;
}
